// =============================================================================
// CONTENT SERVICE DATABASE SCHEMA
// Service: content-service (Port 3017)
// Database: content_db
// Owner: Posts, comments, likes, saves, product tags, content moderation
// =============================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("CONTENT_DATABASE_URL")
}

// =============================================================================
// POSTS (Social commerce content - like Xiaohongshu/Pinterest)
// =============================================================================

model Post {
  id               String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId           String             @map("user_id") @db.Uuid // Reference to User Service (creator)
  postCode         String             @unique @map("post_code") @db.VarChar(50) // PST-XXXXX
  // Content
  title            String?            @db.VarChar(255)
  caption          String             // Main text content
  // Post type
  postType         PostType           @default(standard) @map("post_type")
  // Engagement metrics (denormalized for performance)
  likeCount        Int                @default(0) @map("like_count")
  commentCount     Int                @default(0) @map("comment_count")
  saveCount        Int                @default(0) @map("save_count")
  shareCount       Int                @default(0) @map("share_count")
  viewCount        Int                @default(0) @map("view_count")
  // Status
  status           PostStatus         @default(draft)
  publishedAt      DateTime?          @map("published_at") @db.Timestamptz(6)
  // Visibility
  visibility       PostVisibility     @default(public)
  // Location (optional)
  locationName     String?            @map("location_name") @db.VarChar(255)
  locationLat      Decimal?           @map("location_lat") @db.Decimal(10, 8)
  locationLng      Decimal?           @map("location_lng") @db.Decimal(11, 8)
  // Moderation
  isReported       Boolean            @default(false) @map("is_reported")
  reportCount      Int                @default(0) @map("report_count")
  moderationStatus ModerationStatus   @default(pending) @map("moderation_status")
  moderatedAt      DateTime?          @map("moderated_at") @db.Timestamptz(6)
  moderatedBy      String?            @map("moderated_by") @db.Uuid
  // Timestamps
  createdAt        DateTime           @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime           @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt        DateTime?          @map("deleted_at") @db.Timestamptz(6)

  media           PostMedia[]
  productTags     PostProductTag[]
  hashtags        PostHashtag[]
  likes           PostLike[]
  saves           PostSave[]
  comments        Comment[]
  reports         ContentReport[]

  @@index([userId])
  @@index([postCode])
  @@index([status])
  @@index([publishedAt])
  @@index([deletedAt])
  @@map("post")
}

// =============================================================================
// POST MEDIA (Images/Videos attached to posts)
// =============================================================================

model PostMedia {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId        String    @map("post_id") @db.Uuid
  mediaType     MediaType @map("media_type")
  // URLs
  mediaUrl      String    @map("media_url") // Original/full resolution
  thumbnailUrl  String?   @map("thumbnail_url") // Thumbnail for lists
  // Dimensions
  width         Int?
  height        Int?
  durationSec   Int?      @map("duration_sec") // For videos
  fileSizeBytes Int?      @map("file_size_bytes")
  // Display order
  sortOrder     Int       @default(0) @map("sort_order")
  // Alt text for accessibility
  altText       String?   @map("alt_text") @db.VarChar(500)
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@map("post_media")
}

// =============================================================================
// POST PRODUCT TAGS (Products tagged in posts - key feature!)
// Users can tag ANY product from any store
// =============================================================================

model PostProductTag {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId          String        @map("post_id") @db.Uuid
  // Product reference (to Seller Service or Product Service)
  productId       String        @map("product_id") @db.Uuid
  sellerId        String?       @map("seller_id") @db.Uuid // Seller who owns the product
  productSource   ProductSource @default(seller_product) @map("product_source") // Distinguish product types
  // Position in media (for clickable tags)
  mediaIndex      Int           @default(0) @map("media_index") // Which image in the post (0-indexed)
  positionX       Decimal?      @map("position_x") @db.Decimal(5, 2) // 0-100 percentage
  positionY       Decimal?      @map("position_y") @db.Decimal(5, 2) // 0-100 percentage
  // Snapshot of product info at time of tagging
  productName     String        @map("product_name") @db.VarChar(255)
  productPrice    Decimal       @map("product_price") @db.Decimal(15, 2)
  productImageUrl String?       @map("product_image_url")
  snapshotAt      DateTime      @default(now()) @map("snapshot_at") @db.Timestamptz(6) // When snapshot was taken
  // Tracking
  clickCount      Int           @default(0) @map("click_count")
  purchaseCount   Int           @default(0) @map("purchase_count") // Conversions from this tag
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([postId, productId, productSource, mediaIndex]) // Allow same product on different images
  @@index([productId])
  @@index([sellerId])
  @@index([createdAt])
  @@map("post_product_tag")
}

// =============================================================================
// HASHTAGS
// =============================================================================

model Hashtag {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tag        String   @unique @db.VarChar(100) // Without #, lowercase
  postCount  Int      @default(0) @map("post_count")
  isActive   Boolean  @default(true) @map("is_active")
  isBanned   Boolean  @default(false) @map("is_banned")
  isTrending Boolean  @default(false) @map("is_trending")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  posts PostHashtag[]

  @@index([tag])
  @@index([isTrending])
  @@map("hashtag")
}

model PostHashtag {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId    String   @map("post_id") @db.Uuid
  hashtagId String   @map("hashtag_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  hashtag Hashtag @relation(fields: [hashtagId], references: [id], onDelete: Cascade)

  @@unique([postId, hashtagId])
  @@index([hashtagId])
  @@map("post_hashtag")
}

// =============================================================================
// LIKES
// =============================================================================

model PostLike {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId    String   @map("post_id") @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([userId])
  @@map("post_like")
}

// =============================================================================
// SAVES (Bookmarks)
// =============================================================================

model PostSave {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId       String   @map("post_id") @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  collectionId String?  @map("collection_id") @db.Uuid // Optional: save to specific collection
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  post       Post            @relation(fields: [postId], references: [id], onDelete: Cascade)
  collection SaveCollection? @relation(fields: [collectionId], references: [id], onDelete: SetNull)

  @@unique([postId, userId, collectionId]) // Allow same post in multiple collections
  @@index([userId])
  @@index([collectionId])
  @@map("post_save")
}

model SaveCollection {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  name          String   @db.VarChar(100)
  description   String?  @db.VarChar(500)
  coverImageUrl String?  @map("cover_image_url")
  isPrivate     Boolean  @default(false) @map("is_private")
  postCount     Int      @default(0) @map("post_count")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  saves PostSave[]

  @@index([userId])
  @@map("save_collection")
}

// =============================================================================
// COMMENTS
// =============================================================================

model Comment {
  id               String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  postId           String             @map("post_id") @db.Uuid
  userId           String             @map("user_id") @db.Uuid // Commenter
  parentId         String?            @map("parent_id") @db.Uuid // For replies (nested comments)
  // Content
  content          String             @db.VarChar(2000)
  // Engagement
  likeCount        Int                @default(0) @map("like_count")
  replyCount       Int                @default(0) @map("reply_count")
  // Moderation
  isReported       Boolean            @default(false) @map("is_reported")
  moderationStatus ModerationStatus   @default(approved) @map("moderation_status") // Comments auto-approved by default
  // Timestamps
  createdAt        DateTime           @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime           @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt        DateTime?          @map("deleted_at") @db.Timestamptz(6)

  post     Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent   Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[]     @relation("CommentReplies")
  likes    CommentLike[]
  mentions CommentMention[]
  reports  ContentReport[]

  @@index([postId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("comment")
}

model CommentLike {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  commentId String   @map("comment_id") @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([userId])
  @@map("comment_like")
}

model CommentMention {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  commentId       String   @map("comment_id") @db.Uuid
  mentionedUserId String   @map("mentioned_user_id") @db.Uuid
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([commentId, mentionedUserId])
  @@index([mentionedUserId])
  @@map("comment_mention")
}

// =============================================================================
// CONTENT REPORTS (Moderation)
// =============================================================================

model ContentReport {
  id          String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  reporterId  String        @map("reporter_id") @db.Uuid // User who reported
  // Content reference
  contentType ContentType   @map("content_type") // post, comment
  contentId   String        @map("content_id") @db.Uuid
  postId      String?       @map("post_id") @db.Uuid // For easier querying (when contentType = post)
  commentId   String?       @map("comment_id") @db.Uuid // For easier querying (when contentType = comment)
  // Report details
  reason      ReportReason
  description String?       @db.VarChar(1000)
  // Status
  status      ReportStatus  @default(pending)
  // Resolution
  resolvedAt  DateTime?     @map("resolved_at") @db.Timestamptz(6)
  resolvedBy  String?       @map("resolved_by") @db.Uuid
  resolution  String?       @db.VarChar(500)
  actionTaken ReportAction? @map("action_taken")
  // Timestamps
  createdAt   DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime      @updatedAt @map("updated_at") @db.Timestamptz(6)

  post    Post?    @relation(fields: [postId], references: [id], onDelete: SetNull)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: SetNull)

  @@unique([reporterId, contentType, contentId]) // Prevent duplicate reports
  @@index([reporterId])
  @@index([contentType, contentId])
  @@index([status])
  @@map("content_report")
}

// =============================================================================
// SERVICE OUTBOX (For future Kafka migration)
// =============================================================================

model ServiceOutbox {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  aggregateType String    @map("aggregate_type") @db.VarChar(100)
  aggregateId   String    @map("aggregate_id") @db.Uuid
  eventType     String    @map("event_type") @db.VarChar(100)
  payload       Json
  metadata      Json?
  isPublished   Boolean   @default(false) @map("is_published")
  publishedAt   DateTime? @map("published_at") @db.Timestamptz(6)
  retryCount    Int       @default(0) @map("retry_count")
  lastError     String?   @map("last_error")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  @@index([isPublished, createdAt])
  @@index([aggregateType, aggregateId])
  @@map("service_outbox")
}

// =============================================================================
// ENUMS
// =============================================================================

enum PostType {
  standard      // Regular post with images/video
  review        // Product review post (linked to order)
  lookbook      // Fashion lookbook/outfit post
  tutorial      // How-to/tutorial content
  unboxing      // Unboxing content
}

enum PostStatus {
  draft
  published
  archived
  removed       // Removed by moderation
}

enum PostVisibility {
  public
  followers_only
  private
}

enum MediaType {
  image
  video
}

enum ProductSource {
  seller_product    // Product from seller-service (third-party seller)
  warehouse_product // Product from product-service (LAKOO warehouse)
}

enum ModerationStatus {
  pending       // Awaiting review
  approved      // Approved for display
  flagged       // Flagged for review
  rejected      // Rejected/removed
}

enum ContentType {
  post
  comment
}

enum ReportReason {
  spam
  inappropriate
  harassment
  misinformation
  copyright
  counterfeit   // Fake products
  other
}

enum ReportStatus {
  pending
  under_review
  resolved
  dismissed
}

enum ReportAction {
  none          // No action taken
  warning       // User warned
  content_removed
  user_suspended
  user_banned
}
