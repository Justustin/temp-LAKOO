# Warehouse Service Documentation (`backend/services/warehouse-service`)

This document explains **each file** in the warehouse-service, and (for source files) explains how the logic relates to **routes → controllers → services → repositories → database**. It also includes a middleware section and an endpoint map.

> Notes:
> - `node_modules/` is third‑party and not documented here.
> - `src/generated/prisma/` is **Prisma generated output**; it’s documented as autogenerated (not handwritten business logic).

## High-level overview

### What this service does
- **Inventory state** for product/variant SKUs: `quantity`, `reservedQuantity`, `availableQuantity`, min/max levels, location.
- **Stock reservations** for orders: reserve stock, release reservation, confirm reservation (deduct from total).
- **Inventory movements**: creates an audit trail when stock changes (order fulfilled, adjustments, purchase orders).
- **Grosir (bundle) constraints**: checks whether ordering wholesale bundles would overflow allowed tolerance across variants.
- **Purchase orders**: create POs, update PO status, receive PO items (adds stock and records movements).
- **Stock alerts**: view/acknowledge/resolve alerts (low/out-of-stock, etc.).
- **Domain events**: writes integration events to `ServiceOutbox` (outbox pattern).

### Layering (how code is organized)
- **Routes** (`src/routes/*.routes.ts`): Express endpoints + request validation (via `express-validator`).
- **Controllers** (`src/controllers/*.controller.ts`): HTTP handlers that call service methods.
- **Services** (`src/services/*.service.ts`): business logic; orchestrates repository + Prisma transactions + outbox events.
- **Repositories** (`src/repositories/*.repository.ts`): database access via Prisma for the warehouse domain.
- **Database schema** (`prisma/schema.prisma`): Prisma schema for inventory, reservations, POs, alerts, outbox.
- **Middleware** (`src/middleware/*.ts`): gateway/internal auth, validation result handling, centralized error handler.

### Request flow (typical)
1. **Route** applies auth middleware and validators.
2. **Controller** reads params/body, calls a **Service** method.
3. **Service** runs business logic (often inside a Prisma transaction), calls repository helpers, and writes outbox events.
4. Response returned; async errors bubble to the centralized `errorHandler`.

## Environment variables (what the code expects)

Common variables referenced across files:
- **`PORT`**: Express listen port (`src/index.ts` defaults to `3012`).
- **`NODE_ENV`**: affects logging and dev auth bypass behavior (`development`/`test`/`production`).
- **`DATABASE_URL`**: Postgres connection string used by Prisma.
- **`GATEWAY_SECRET_KEY`**: shared secret used to verify requests came from the API Gateway (`x-gateway-key` header).
- **`INTERNAL_API_KEY`**: API key for internal service-to-service calls (`x-internal-api-key` header).
- **`RESERVATION_EXPIRY_HOURS`**: number of hours before a reservation is considered expired (used when creating `StockReservation.expiresAt`).

## Local development

### Install & run
From repo root:
- **Install dependencies**:
  - `pnpm -C backend/services/warehouse-service install`
- **Generate Prisma client**:
  - `pnpm -C backend/services/warehouse-service prisma:generate`
- **Run migrations** (dev):
  - `pnpm -C backend/services/warehouse-service prisma:migrate`
- **Start dev server**:
  - `pnpm -C backend/services/warehouse-service dev`

### Build & tests
- **Build**: `pnpm -C backend/services/warehouse-service build`
- **Tests**: `pnpm -C backend/services/warehouse-service test`

## Authentication model (gateway-trust + internal key)

This service assumes **JWT validation happens at the API Gateway**. The service verifies that the request really came from the gateway using a shared secret header:
- **Gateway traffic**:
  - `x-gateway-key`: must match `GATEWAY_SECRET_KEY`
  - `x-user-id`: required
  - `x-user-role`: optional
- **Internal service-to-service traffic**:
  - `x-internal-api-key`: must match `INTERNAL_API_KEY`
  - optional `x-user-id` (defaults to `internal-service`)

> Dev-mode bypass: In `NODE_ENV=development`, if no key is configured, the middleware allows requests through with a `dev-user` identity. Do not deploy with `NODE_ENV=development`.

## Endpoint → Controller → Service/Repo map

### Warehouse (public + internal) (`/api/warehouse/*`) — `src/routes/warehouse.routes.ts`
Route-level auth: `gatewayOrInternalAuth` + `validateRequest`

- **GET `/api/warehouse/inventory/status`**
  - Query: `productId` (uuid), optional `variantId` (uuid)
  - Controller: `WarehouseController.getInventoryStatus`
  - Service: `WarehouseService.getInventoryStatus`
  - Repo: `WarehouseRepository.findInventory`

- **GET `/api/warehouse/check-bundle-overflow`**
  - Query: `productId`, optional `variantId`
  - Controller: `WarehouseController.checkBundleOverflow`
  - Service: `WarehouseService.checkBundleOverflow`
  - Repo: `WarehouseRepository.findBundleConfig`, `WarehouseRepository.findAllTolerances`, `WarehouseRepository.findInventory`

- **GET `/api/warehouse/check-all-variants`**
  - Query: `productId`
  - Controller: `WarehouseController.checkAllVariantsOverflow`
  - Service: `WarehouseService.checkAllVariantsOverflow`
  - Repo: `WarehouseRepository.findBundleConfig`, `WarehouseRepository.findAllTolerances`, `WarehouseRepository.findInventory`

- **POST `/api/warehouse/reserve-inventory`**
  - Body: `productId`, optional `variantId`, `quantity`, `orderId`, optional `orderItemId`
  - Controller: `WarehouseController.reserveInventory`
  - Service: `WarehouseService.reserveInventory`
  - Repo: `WarehouseRepository.findInventory`, `WarehouseRepository.atomicReserveStock`
  - DB: creates `StockReservation`, updates `WarehouseInventory`
  - Events: outbox `inventory.reserved`, maybe `inventory.low_stock` / `inventory.out_of_stock`

- **POST `/api/warehouse/release-reservation`**
  - Body: `reservationId`, optional `reason`
  - Controller: `WarehouseController.releaseReservation`
  - Service: `WarehouseService.releaseReservation`
  - Repo: `WarehouseRepository.findReservation`
  - DB: updates `StockReservation` status, returns stock to `availableQuantity`
  - Events: outbox `inventory.released`

- **POST `/api/warehouse/confirm-reservation`**
  - Body: `reservationId`
  - Controller: `WarehouseController.confirmReservation`
  - Service: `WarehouseService.confirmReservation`
  - Repo: `WarehouseRepository.findReservation`
  - DB: updates `StockReservation` to confirmed; decrements `WarehouseInventory.quantity`; creates `InventoryMovement`
  - Events: outbox `inventory.confirmed`

### Admin (`/api/admin/*`) — `src/routes/admin.routes.ts`
Route-level auth: `gatewayOrInternalAuth` + `requireRole('admin', 'warehouse_admin', 'internal')`

#### Inventory management
- **GET `/api/admin/inventory`**
  - Controller: `WarehouseController.getAllInventory`
  - Service: `WarehouseService.getAllInventory`
  - Repo: `WarehouseRepository.findAllInventory`
  - Notes: `lowStock=true` is filtered in code because Prisma can’t compare columns in `where`.

- **POST `/api/admin/inventory`**
  - Controller: `WarehouseController.createInventory`
  - Service: `WarehouseService.createInventory`
  - Repo: `WarehouseRepository.createInventory`

- **POST `/api/admin/inventory/adjust`**
  - Controller: `WarehouseController.adjustInventory`
  - Service: `WarehouseService.adjustInventory`
  - Repo/DB: updates `WarehouseInventory` and creates `InventoryMovement` in a transaction

- **GET `/api/admin/inventory/movements`**
  - Query: `productId`, optional `variantId`, optional `limit`
  - Controller: `WarehouseController.getMovementHistory`
  - Service: `WarehouseService.getMovementHistory`
  - Repo: `WarehouseRepository.findMovementsByInventory`

#### Grosir configuration
- **POST `/api/admin/bundle-config`**
  - Controller: `WarehouseController.updateBundleConfig`
  - Service: `WarehouseService.updateBundleConfig`
  - Repo: `WarehouseRepository.upsertBundleConfig`

- **POST `/api/admin/tolerance`**
  - Controller: `WarehouseController.updateTolerance`
  - Service: `WarehouseService.updateTolerance`
  - Repo: `WarehouseRepository.upsertTolerance`

#### Stock alerts
- **GET `/api/admin/alerts`**
  - Controller: `WarehouseController.getActiveAlerts`
  - Service: `WarehouseService.getActiveAlerts`
  - Repo: `WarehouseRepository.findActiveAlerts`

- **POST `/api/admin/alerts/:id/acknowledge`**
  - Controller: `WarehouseController.acknowledgeAlert`
  - Service: `WarehouseService.acknowledgeAlert`
  - Repo: `WarehouseRepository.acknowledgeAlert`

- **POST `/api/admin/alerts/:id/resolve`**
  - Controller: `WarehouseController.resolveAlert`
  - Service: `WarehouseService.resolveAlert`
  - Repo: `WarehouseRepository.resolveAlert`

#### Purchase orders
- **GET `/api/admin/purchase-orders`**
  - Controller: `WarehouseController.getPurchaseOrders`
  - Service: `WarehouseService.getPurchaseOrders`
  - Repo: `WarehouseRepository.findAllPurchaseOrders`

- **GET `/api/admin/purchase-orders/:id`**
  - Controller: `WarehouseController.getPurchaseOrder`
  - Service: `WarehouseService.getPurchaseOrder`
  - Repo: `WarehouseRepository.findPurchaseOrder`

- **POST `/api/admin/purchase-orders`**
  - Controller: `WarehouseController.createPurchaseOrder`
  - Service: `WarehouseService.createPurchaseOrder`
  - Repo: `WarehouseRepository.createPurchaseOrder`
  - Events: outbox `purchase_order.created`

- **PATCH `/api/admin/purchase-orders/:id/status`**
  - Controller: `WarehouseController.updatePurchaseOrderStatus`
  - Service: `WarehouseService.updatePurchaseOrderStatus`
  - Repo: `WarehouseRepository.updatePurchaseOrderStatus`

- **POST `/api/admin/purchase-orders/:id/receive`**
  - Controller: `WarehouseController.receivePurchaseOrder`
  - Service: `WarehouseService.receivePurchaseOrder`
  - DB: wrapped in a single Prisma transaction:
    - updates PO item received/damaged (cumulative)
    - increments inventory
    - creates `InventoryMovement`
    - updates PO status based on DB state
  - Events (after commit): outbox `inventory.restocked` (per item), `purchase_order.received`

## Middleware (thorough)

### `src/middleware/auth.ts`
Implements gateway-trust + internal auth and role checks.

- **`gatewayAuth`**: validates `x-gateway-key` against `GATEWAY_SECRET_KEY`, extracts `x-user-id` and `x-user-role`.
- **`gatewayOrInternalAuth`**: accepts either gateway key or internal API key.
- **`internalAuth`**: internal-only key.
- **`requireRole(...roles)`**: role-based authorization using `req.user.role`.

### `src/middleware/validation.ts`
Implements `express-validator` checks and a shared result handler:
- **`validateRequest(req,res,next)`**: returns 400 with `{ success:false, error:'Validation failed', details:[...] }` when validators failed.
- Exports per-route validator arrays: inventory, reservations, bundle checks, purchase orders, alerts.

### `src/middleware/error-handler.ts`
Defines typed operational errors and centralized response formatting:
- `AppError` + subclasses (`BadRequestError`, `UnauthorizedError`, `ForbiddenError`, `NotFoundError`, `ConflictError`)
- `errorHandler`: handles `AppError`, Prisma errors (`P2002`, `P2025`), and defaults to 500.
- `asyncHandler`: promise wrapper for Express handlers.

## Outbox events (domain integration)

### Where events are written
`src/services/outbox.service.ts` writes rows to the `ServiceOutbox` table (`prisma.serviceOutbox.create`).

### Event types
Inventory:
- `inventory.reserved`, `inventory.released`, `inventory.confirmed`
- `inventory.low_stock`, `inventory.out_of_stock`, `inventory.restocked`

Variant:
- `variant.locked`, `variant.unlocked` (currently supported by the outbox service)

Purchase orders:
- `purchase_order.created`, `purchase_order.received` (others exist in the union but may not be used yet)

Stock alerts:
- `stock_alert.triggered`, `stock_alert.acknowledged`, `stock_alert.resolved` (event creation is not wired everywhere yet)

> Important: This service currently **writes to outbox**. A separate worker/publisher is required to read `ServiceOutbox` and publish to Kafka (or another broker).

### Outbox coverage checklist (wired vs missing)

Events currently emitted by the service code today (high-signal list):
- `inventory.reserved` (+ sometimes `inventory.low_stock` / `inventory.out_of_stock`) during `POST /api/warehouse/reserve-inventory`
- `inventory.released` during `POST /api/warehouse/release-reservation`
- `inventory.confirmed` during `POST /api/warehouse/confirm-reservation`
- `purchase_order.created` during `POST /api/admin/purchase-orders`
- `inventory.restocked` (per received item) + `purchase_order.received` during `POST /api/admin/purchase-orders/:id/receive`

Common outbox flows you may still want to wire (depending on your MVP needs):
- `inventory.created` / `inventory.updated` when creating or adjusting inventory (currently not emitted)
- `stock_alert.*` events (declared, but not emitted by current service logic)
- `variant.locked` / `variant.unlocked` events (declared; locking/unlocking is not currently performed by service logic)

### Transactional outbox note (important)

For the strict transactional-outbox guarantee, the **domain state change** and the **outbox insert** should be written in the same database transaction (e.g., `prisma.$transaction`). Some flows currently do “DB update(s) → outbox insert” as separate steps.

## Swagger / API docs note
Route files contain `@swagger` JSDoc blocks, and `GET /` returns `docs: '/api-docs'`. However, there is currently **no swagger-ui route mounted** in `src/index.ts`. If you want live docs, add Swagger tooling (e.g. `swagger-ui-express`) or remove the `/api-docs` reference.

## Known gaps / tech debt (things to revisit)

- Inventory reservation atomicity: `reserveInventory()` updates inventory first (atomicReserveStock), then creates a `StockReservation`, then writes outbox events. A crash between these steps can leave “reserved stock without a reservation row”.
- Purchase order receive concurrency: `receivePurchaseOrder()` currently calculates `newReceivedUnits = poItem.receivedUnits + item.receivedUnits` using a pre-fetched `po` snapshot; concurrent receives can overwrite each other unless the update is done as DB-side increments or based on fresh reads inside the transaction.
- Reservation expiry processing: reservations have `expiresAt` and the repository can find expired reservations, but there is no job/worker endpoint shown here that automatically expires and releases them.
- Stock alerts persistence: the schema supports `StockAlert` and the admin endpoints can read/ack/resolve, but creation of alerts is not obviously wired from low/out-of-stock situations (today these are emitted as outbox events).
- Grosir tolerance fields: overflow checks reference tolerance fields like `currentExcess` / `isLocked`, but the logic that updates `currentExcess` and actively locks/unlocks variants is not covered in the current service flows.

## File-by-file documentation

### Root files

#### `package.json`
Scripts:
- `dev`: `tsx watch src/index.ts`
- `build`: `tsc`
- `start`: `node dist/index.js`
- `test`: `jest`
- Prisma: `prisma:generate`, `prisma:migrate`, `prisma:deploy`, `prisma:studio`, `db:push`

#### `tsconfig.json`
TypeScript compiler configuration for Node (module `NodeNext`). Tests (`**/*.test.ts`) are excluded from `tsc` build.

#### `jest.config.js`
Jest config using `ts-jest`. Unit tests live under `src/` and match `*.test.ts`.

#### `prisma/schema.prisma`
Database schema for:
- `WarehouseInventory`
- `InventoryMovement`
- `StockReservation`
- `GrosirBundleConfig`
- `GrosirWarehouseTolerance`
- `WarehousePurchaseOrder` + `PurchaseOrderItem`
- `StockAlert`
- `ServiceOutbox`

### Source files (`src/`)

#### `src/index.ts`
Express setup:
- Security middleware: `helmet`, `cors`
- Logging: `morgan` (disabled in `test`)
- JSON body parsing
- Routes: `/api/warehouse`, `/api/admin`
- `GET /health`
- `errorHandler` mounted last

#### `src/controllers/warehouse.controller.ts`
HTTP entrypoints for inventory, reservations, grosir checks, alerts, and purchase orders. Each handler delegates to `WarehouseService` and returns JSON responses.

#### `src/services/warehouse.service.ts`
Core business logic:
- Inventory status aggregation
- Reservation lifecycle (reserve/release/confirm)
  - Uses optimistic locking + atomic update to prevent oversell
- Grosir bundle overflow checks
- Admin inventory adjustments (with movements)
- Purchase order orchestration (create, update status, receive)
  - Receive is wrapped in a single transaction; events are written after commit

#### `src/repositories/warehouse.repository.ts`
Prisma reads/writes for warehouse aggregates:
- Inventory operations and atomic reserve
- Reservation reads/updates
- Movement creation and history
- Bundle config + tolerance CRUD
- Purchase order CRUD + status updates
- Stock alert CRUD

#### `src/services/outbox.service.ts`
Outbox writer with typed event unions and payload interfaces.

#### `src/middleware/*`
Auth/validation/error handling helpers (see Middleware section above).

#### `src/utils/bundleCalculation.ts`
Pure functions for computing bundles needed, fulfillment checks, actual received quantity, and wastage.

#### `src/utils/bundleCalculation.test.ts`
Unit tests validating the bundle calculation rules and edge cases.

### Autogenerated files

#### `src/generated/prisma/*`
Prisma client output. Do not edit by hand; regenerate with `pnpm prisma:generate`.

